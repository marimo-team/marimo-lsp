import type { components as Api } from "@marimo-team/openapi/src/api";
import type * as vscode from "vscode";
import type * as lsp from "vscode-languageclient/node";
import type { MarimoNotebook, NotebookCellId, NotebookId } from "./schemas.ts";

export type { CellRuntimeState } from "@marimo-team/frontend/unstable_internal/core/cells/types.ts";

type Schemas = Api["schemas"];

export type Notification = Schemas["KnownUnions"]["notification"];
export type NotificationOf<T extends Notification["op"]> = Extract<
  Notification,
  { op: T }
>;
export type CellOperationNotification = NotificationOf<"cell-op">;
export type VariableValuesNotification = NotificationOf<"variable-values">;
export type VariablesNotification = NotificationOf<"variables">;
export type DataColumnPreviewNotification =
  NotificationOf<"data-column-preview">;
export type DataSourceConnectionsNotification =
  NotificationOf<"data-source-connections">;
export type DatasetsNotification = NotificationOf<"datasets">;
export type SqlTablePreviewNotification = NotificationOf<"sql-table-preview">;
export type SqlTableListPreviewNotification =
  NotificationOf<"sql-table-list-preview">;

export type MarimoConfig = Schemas["MarimoConfig"];

interface NotebookScoped<T> {
  notebookUri: NotebookId;
  inner: T;
}

interface SessionScoped<T> extends NotebookScoped<T> {
  executable: string;
}

type ExecuteCellsRequest = Schemas["ExecuteCellsRequest"];
type UpdateUIElementRequest = Schemas["UpdateUIElementRequest"];
type InvokeFunctionRequest = Schemas["InvokeFunctionRequest"];
type DeleteCellRequest = Schemas["DeleteCellRequest"];
type ExportAsHtmlRequest = Schemas["ExportAsHTMLRequest"];
interface DeserializeRequest {
  source: string;
}
interface SerializeRequest {
  notebook: typeof MarimoNotebook.Type;
}
interface DebugAdapterRequest {
  sessionId: string;
  message: vscode.DebugProtocolMessage;
}
// biome-ignore lint/complexity/noBannedTypes: We need this for over the wire
type InterruptRequest = {};
// biome-ignore lint/complexity/noBannedTypes: We need this for over the wire
type ListPackagesRequest = {};
// biome-ignore lint/complexity/noBannedTypes: We need this for over the wire
type DependencyTreeRequest = {};
// biome-ignore lint/complexity/noBannedTypes: We need this for over the wire
type GetConfigurationRequest = {};
// biome-ignore lint/complexity/noBannedTypes: We need this for over the wire
type CloseSessionRequest = {};

interface ExecuteScratchRequest {
  code: string;
}

interface UpdateConfigurationRequest {
  config: Record<string, unknown>;
}

// API methods routed through marimo.api
type MarimoApiMethodMap = {
  // marimo core API
  "execute-cells": SessionScoped<ExecuteCellsRequest>;
  "update-ui-element": NotebookScoped<UpdateUIElementRequest>;
  "invoke-function": NotebookScoped<InvokeFunctionRequest>;
  "delete-cell": NotebookScoped<DeleteCellRequest>;
  "get-package-list": SessionScoped<ListPackagesRequest>;
  "get-dependency-tree": SessionScoped<DependencyTreeRequest>;
  "get-configuration": NotebookScoped<GetConfigurationRequest>;
  "update-configuration": NotebookScoped<UpdateConfigurationRequest>;
  "close-session": NotebookScoped<CloseSessionRequest>;
  "execute-scratchpad": NotebookScoped<ExecuteScratchRequest>;
  "export-as-html": NotebookScoped<ExportAsHtmlRequest>;
  interrupt: NotebookScoped<InterruptRequest>;
  // marimo-lsp API
  dap: NotebookScoped<DebugAdapterRequest>;
  serialize: SerializeRequest;
  deserialize: DeserializeRequest;
};

type ApiRequest<K extends keyof MarimoApiMethodMap> = {
  [M in keyof MarimoApiMethodMap]: {
    method: M;
    params: MarimoApiMethodMap[M];
  };
}[K];

// client -> language server
type MarimoCommandMap = {
  "marimo.api": ApiRequest<keyof MarimoApiMethodMap>;
  "marimo.convert": { uri: string };
};

type MarimoCommandMessageOf<K extends keyof MarimoCommandMap> = {
  [C in keyof MarimoCommandMap]: {
    command: C;
    params: MarimoCommandMap[C];
  };
}[K];

/**
 * Subset of API methods allowed to be dispatched by the renderer.
 *
 * The renderer handles two types of messages:
 *
 * 1. **From marimo UI components** (`update-ui-element`, `invoke-function`):
 *    - Interactive widgets like sliders, buttons, etc. send these when users interact with them
 *    - These are part of marimo's core reactive execution model
 *
 * 2. **From HTML output generated by the extension** (`navigate-to-cell`):
 *    - Error messages and other HTML output can include interactive elements
 *    - When users click links in error messages, the HTML posts messages that the renderer forwards
 *    - Example: "Variable 'x' was defined in [cell-2]" - clicking "cell-2" triggers navigate_to_cell
 *
 * All messages flow through the renderer (which runs in the notebook output iframe) to the
 * extension (which has access to the VSCode API and notebook editor).
 */
type RendererCommandMap = {
  // Forward to extension marimo.api
  "update-ui-element": MarimoApiMethodMap["update-ui-element"]["inner"];
  "invoke-function": MarimoApiMethodMap["invoke-function"]["inner"];
  // Custom
  "navigate-to-cell": { cellId: NotebookCellId };
};
type RendererCommandMessageOf<K extends keyof RendererCommandMap> = {
  [C in keyof RendererCommandMap]: {
    command: C;
    params: RendererCommandMap[C];
  };
}[K];

export type MarimoCommand = MarimoCommandMessageOf<keyof MarimoCommandMap>;

// renderer -> extension
export type RendererCommand = RendererCommandMessageOf<
  keyof RendererCommandMap
>;

// extension -> renderer
export type RendererReceiveMessage =
  | NotificationOf<"remove-ui-elements">
  | NotificationOf<"send-ui-element-message">
  | NotificationOf<"function-call-result">;

// Language server -> client
type MarimoLspNotificationMap = {
  "marimo/operation": { notebookUri: NotebookId; operation: Notification };
  "marimo/dap": { sessionId: string; message: vscode.DebugProtocolMessage };
  "window/logMessage": lsp.LogMessageParams;
};
export type MarimoLspNotification = keyof MarimoLspNotificationMap;
export type MarimoLspNotificationOf<K extends MarimoLspNotification> = {
  [C in MarimoLspNotification]: MarimoLspNotificationMap[C];
}[K];

/**
 * Commands that HTML output can send to the renderer.
 *
 * The extension generates HTML output (e.g., error messages) that may include interactive
 * elements. Since this HTML runs in the renderer's iframe, it can't directly call VSCode APIs.
 * Instead, the HTML uses `window.parent.postMessage()` to send messages to the renderer,
 * which forwards them to the extension.
 *
 * Flow: HTML onclick → window.parent.postMessage() → renderer.tsx → KernelManager.ts
 *
 * Example: Error messages include `<a onclick="postMessage({command: 'navigate_to_cell', ...})">cell-2</a>`
 *
 * To add new interactions: Add to RendererCommandMap and include in MarimoHtmlPublish.
 */
export type MarimoHtmlPublish = keyof Pick<
  RendererCommandMap,
  "navigate-to-cell"
>;
export type MarimoHtmlPublishOf<K extends MarimoHtmlPublish> =
  RendererCommandMessageOf<K>;
export type MarimoHtmlPublishMessage = MarimoHtmlPublishOf<MarimoHtmlPublish>;

/**
 * Type-safe helper to create a cell navigation link in HTML output.
 *
 * @param cellUri The URI of the cell to navigate to (e.g., "vscode-notebook-cell://...")
 * @param label The display text for the link (e.g., "cell-2")
 * @returns HTML string with embedded onclick handler
 */
export function createCellNavigationLink(
  cellId: NotebookCellId,
  cellIndex: number,
): string {
  const msg: MarimoHtmlPublishOf<"navigate-to-cell"> = {
    command: "navigate-to-cell",
    params: { cellId },
  };
  const encoded = JSON.stringify(msg).replace(/"/g, "&quot;");
  return `<a href="#" data-message="${encoded}" onclick="event.preventDefault(); window.parent.postMessage(JSON.parse(this.getAttribute('data-message')), '*'); return false;">cell-${cellIndex}</a>`;
}
